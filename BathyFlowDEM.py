# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BathyFlowDEM
                                 A QGIS plugin
 Interpolation plugin for bathymetric data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-12-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Melinda Femminis
        email                : Contact
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

import math

from qgis.core import Qgis, QgsProject, QgsVectorDataProvider, QgsField, QgsGeometry, QgsPointXY, QgsFeatureRequest, QgsRasterLayer, QgsRasterFileWriter
from qgis.utils import iface
from qgis.core.additions.edit import edit
import processing
from qgis.analysis import QgsIDWInterpolator

from osgeo import gdal, osr
from osgeo.gdalconst import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .BathyFlowDEM_dialog import BathyFlowDEMDialog

import os.path
from qgis.core import QgsMapLayerProxyModel, QgsFieldProxyModel






class BathyFlowDEM:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        # Save reference to the QGIS interface
        self.iface = iface                                                                                                                          
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'BathyFlowDEM_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&BathyFlowDEM')

        # Create instance of dialog class
        self.dlg = BathyFlowDEMDialog()

        


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('BathyFlowDEM', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action
    




    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/BathyFlowDEM/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Create DEM'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # Connect dialog signals and slots
        self.dlg.cbInputPoints.layerChanged.connect(self.onCbInputPointsWidget_layerChanged)

        # Populate attribute field with selected point layer
        self.onCbInputPointsWidget_layerChanged()




    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&BathyFlowDEM'),
                action)
            self.iface.removeToolBarIcon(action)



    # Errors and exceptions functions
    def check_data_inputs(self, points, centerline, polygon):
        if points == None or centerline == None or polygon == None:
            self.iface.messageBar().pushMessage("Error", "All input fields must have a layer selected.", level=Qgis.Critical)
            pass
        elif str(points.fields().names()) != [str(['x', 'y', 'z']), str(['X', 'Y', 'Z'])]:
            self.iface.messageBar().pushMessage("Error", "Point layer's fields' names must be X,Y,Z. Modify and try again.", level=Qgis.Critical)
            pass
        else: 
            print(points.fields.names())
            return True   




    def onCbInputPointsWidget_layerChanged(self):
        """Slot method called when the seleted layer in cbInputPoints is changed"""

        current_point_layer = self.dlg.cbInputPoints.currentLayer()
        self.dlg.cbAttributeFields.setLayer(current_point_layer)
        self.dlg.cbAttributeFields.setFilters(QgsFieldProxyModel.Numeric)
        print("Point layer changed method.")


















    ########################################################################
    ##
    ## Find the distance along a line
    ##
    ########################################################################
    
    

    def conversion_infos(self, points, centerline):
        """ Function that returns a dictionnary with, for each point, the side of the line it is located in "side" and the 
        distance along the center line in "distance". """

        # Initialize a dictionary to store distances along the line for each point
        results_dir = {}

        line_feature = next(centerline.getFeatures())
        line_geom = line_feature.geometry()

        # Iterate over each feature in the point layer
        for point_feature in points.getFeatures():
            point_geom = point_feature.geometry()
            # closestSegmentWithContext() returns a tuple with [point, nearest point on segment, ]
            minDist, closest_pt, afterVertex, leftOf = line_geom.closestSegmentWithContext(point_geom.asPoint())

            # To know on which side of the center line the point lies
            side = leftOf

            # To know the distance along the center line for each point
            distance_along_line = line_geom.lineLocatePoint(point_geom)

            # To know flow direction 
            before_vertex_index = afterVertex - 1

            start_point = line_geom.vertexAt(before_vertex_index)
            end_point = line_geom.vertexAt(afterVertex)

            # Calculate flow direction as an angle
            if start_point and end_point:

                dx = end_point.x() - start_point.x()
                dy = end_point.y() - start_point.y()
                angle_rad = math.atan2(dy, dx)
                angle_deg = math.degrees(angle_rad)
            else:
                angle_deg = None
        

            results_dir[point_feature.id()] = {'side': side, 
                                                    'distance_along_line': distance_along_line,
                                                    'flowdir': angle_deg}

        return results_dir







    ########################################################################
    ##
    ## Define flow direction for each point
    ##
    ########################################################################

    def flowdirections(self, centerline_layer, survey_points_layer):
        """
        Calculates flow direction for each segment

        Args:
            centerline_layer (QgsVectorLayer): Input layer with a single line of flow direction
            survey_points_layer (QgsVectorLayer): Input layer for which flow direction will be calculated

        Returns:
            list: Flow direction for each point in order
        """

        flow_directions = []  # Store flow direction for each survey point

        line_feature = next(centerline_layer.getFeatures())
        line_geom = line_feature.geometry()

        for point_feat in survey_points_layer.getFeatures():
            
            # Convert survey point to QgsPointXY for distance calculations
            survey_point = point_feat.geometry().asPoint()
            

            # Using QgsGeometry's closestSegmentWithContext method
            minDist, closest_pt, afterVertex, leftOf = line_geom.closestSegmentWithContext(QgsPointXY(survey_point))

            before_vertex_index = afterVertex - 1

            start_point = line_geom.vertexAt(before_vertex_index)
            end_point = line_geom.vertexAt(afterVertex)
    

            # Calculate flow direction as an angle
            if start_point and end_point:

                dx = end_point.x() - start_point.x()
                dy = end_point.y() - start_point.y()
                angle_rad = math.atan2(dy, dx)
                angle_deg = math.degrees(angle_rad)
                flow_directions.append(angle_deg)
            else:
                flow_directions.append(None)
        
        
        return flow_directions
    















    ########################################################################
    ##
    ## Interpolation
    ##
    ########################################################################
        
    def eidw(self, target_s, target_n, value_field, point_layer, anisotropy_ratio, max_distance):
        """
        Perform IDW interpolation using anisotropy along the already aligned S and N coordinates.

        Args:
            point_layer (QgsVectorLayer): Input layer with point features containing S, N, and Z.
            value_field (str): Name of the field with values to interpolate.
            target_s (float): Target point's S coordinate.
            target_n (float): Target point's N coordinate.
            anisotropy_ratio (float): Factor by which distances across the flow (N direction) are scaled.

        Returns:
            float: Interpolated value at the target location.
        """
        print("In the eidw function.")

        sum_weighted_values = 0
        sum_weights = 0
        distances = []
        
        for feature in point_layer.getFeatures():
            s = feature['S']
            n = feature['N']
            value = feature[value_field]
            
            # Calculate distances in the S and N directions
            ds = s - target_s
            dn = (n - target_n) * anisotropy_ratio

            # Calculate the anisotropic distance by modifying it on the N axis
            distance = (ds**2 + dn**2) ** 0.5

            if distance <= max_distance:
                distances.append((distance, value))
            
            if distance < 0.0001:  # If point is right on it/super close
                return value
            
        print(distances[1][0])
        print(distances[1][1])
            

        for distance, value, in distances:
            weight = 1 / distance
            sum_weights += weight
            sum_weighted_values += weight * value
        
        if sum_weights == 0:
            return None 
        
        return sum_weighted_values / sum_weights
              
        











    def run(self):
        """Run method that performs all the real work"""





        ########################################################################
        ##
        ## Set the dialog window, restrictions and updates
        ##
        ########################################################################

        # Restrict the type of layer that can be selected in the combo boxes
        self.dlg.cbInputBoundary.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dlg.cbInputPoints.setFilters(QgsMapLayerProxyModel.PointLayer)
        self.dlg.cbInputCenterline.setFilters(QgsMapLayerProxyModel.LineLayer)

        # PLaceholders for output layer name
        self.dlg.leOutputName.setPlaceholderText("bathyflowDEM_output")

        # show the dialog
        self.dlg.show()

        # Run the dialog event loop
        result = self.dlg.exec_()

        # Populate attribute field with selected point layer - and update is changed
        self.onCbInputPointsWidget_layerChanged()
        
    





        # See if OK was pressed
        if result:



            ########################################################################
            ##
            ## Get selected user's values INPUTS and OUTPUT choice/destination
            ##
            ########################################################################
            
            # Get user input layers
            point_layer = self.dlg.cbInputPoints.currentLayer()
            centerline_layer = self.dlg.cbInputCenterline.currentLayer()
            boundary_layer = self.dlg.cbInputBoundary.currentLayer()

            # Other parameters
            cell_size = self.dlg.sbCellSize.value()
            show_output_checked = self.dlg.cbOpenOutputFile.isChecked()

            # Get user output path 
            user_output_dir_path = self.dlg.saveDirWidget.filePath() # might be empty
            print("User dir " + str(user_output_dir_path))
            user_output_layer_name = self.dlg.leOutputName.displayText() # might be empty
            print("User layer name " + str(user_output_layer_name))

            # Define user output path. If no directory selected, layer name is ditched. Otherwise build full path.
            if not user_output_dir_path:
                pass
            else:
                if not user_output_layer_name:
                    output_path = user_output_dir_path + "\\bathyflowdem_output.shp"
                else:
                    output_path = user_output_dir_path + "\\" + user_output_layer_name + ".shp"

        
            



            





            
            ########################################################################
            ##
            ## Create new points layer with X, Y, S and N coordinates and flow direction
            ##
            ########################################################################       

            # Clone input shp point layer: comes with all attributes: id, X and Y
            point_layer.selectAll()
            point_layer_xy_sn = processing.run("native:saveselectedfeatures", {'INPUT': point_layer,
                                                                               'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
            point_layer.removeSelection()
            point_layer_xy_sn.setName('points_xy_and_sn')
            print(point_layer_xy_sn)
            
            # To enable check of a particular capability 
            pl_caps = point_layer_xy_sn.dataProvider().capabilities()

            # Create list of new fields
            pl_new_fields = [
                QgsField("S", QVariant.Double),
                QgsField("N", QVariant.Double),
                QgsField("FlowDir", QVariant.Double),
            ]

            # Add fields to layer and update layer
            if pl_caps & QgsVectorDataProvider.AddAttributes:
                 point_layer_xy_sn.dataProvider().addAttributes(pl_new_fields)
            point_layer_xy_sn.updateFields()




            ########################################################################
            ## Get flow direction for all points
            ########################################################################

            #flow_direction = self.flowdirections(centerline_layer, point_layer_xy_sn)



            ########################################################################
            ## Get N for each point, the distance to the centerline
            ########################################################################

            short_dist_params = {
            'SOURCE': point_layer_xy_sn,
            'DESTINATION': centerline_layer,
            'METHOD': 0,
            'NEIGHBORS': 1,
            'END_OFFSET': 0,
            'OUTPUT': 'TEMPORARY_OUTPUT'
            }
             # Run the algorithm
            shortest_dist_point_centerline_layer = processing.run("native:shortestline", short_dist_params)['OUTPUT']



            ########################################################################
            ## Get S for each point, the distance along the centerline
            ########################################################################

            infos_dict = self.conversion_infos(centerline=centerline_layer, points=point_layer_xy_sn)
            print(infos_dict)


            ########################################################################
            ## Populate the new layer with S, N and FlowDir values
            ########################################################################

            with edit(point_layer_xy_sn):

                for f in point_layer_xy_sn.getFeatures():

                    # Retrieve n, calculated by the shortest_distance algorithm
                    # setFilterFid() needs row number, not id so add 1
                    row = f['id'] + 1
                    iterator = shortest_dist_point_centerline_layer.getFeatures(QgsFeatureRequest().setFilterFid(row))
                    feature = next(iterator)
                    n_coordinate = feature['distance']
                    
                    # Change the sign to negative according to which side of the centerline the point it located
                    if infos_dict[f.id()]['side'] == -1:
                        n_coordinate *= -1

                    flow_direction =  infos_dict[f.id()]['flowdir']

                    s_coordinate = infos_dict[f.id()]['distance_along_line']

                    # Add values to the layer
                    point_layer_xy_sn.changeAttributeValue(f.id(), 4, s_coordinate)
                    point_layer_xy_sn.changeAttributeValue(f.id(), 5, n_coordinate)   
                    point_layer_xy_sn.changeAttributeValue(f.id(), 6, flow_direction)            



            # Add new layer to project
            QgsProject.instance().addMapLayer(point_layer_xy_sn)

            s = 39
            n = 3.9
            target_z = self.eidw(s, n, 'Z', point_layer_xy_sn, 1, 150)
            print(target_z)















            """Tests and errors"""
            # self.check_data_inputs(point_layer, centerline_layer, boundary_layer)


            if show_output_checked == True:

                # No output dir selected, no layer name but load layer checked
                if not user_output_dir_path and not user_output_layer_name: 
                    print("Load layer to map checked, no dir and not output name.")

                    """ new_layer = processing.runAndLoadResults("native:centroids", {'INPUT':boundary_layer,
                                                                                  'ALL_PARTS':False,
                                                                                  'OUTPUT':'TEMPORARY_OUTPUT', 
                                                                                  'NAME':'bathyflowDEM_output'})"""
                    
                # if there is a dir path, output path was defined earlier
                elif not user_output_dir_path:
                    print("Load layer to map checked, no dir path selected so only temp.")
                    """ new_layer = processing.runAndLoadResults("native:centroids", {'INPUT':boundary_layer,
                                                                                  'ALL_PARTS':False,
                                                                                  'OUTPUT': output_path}) """

                else:
                    print("Load layer to map checked, dir selected so load in project + export with output path.")
                    self.iface.messageBar().pushMessage("BathyFlowDEM", "Finished. New layer saved at " + output_path, level=Qgis.Success)

            else:

                # if no output dir selected
                if not user_output_dir_path: # wether user added filename or not
                    print("ERROR, there is no saving path and no load to project. Choose one method.")
                    self.iface.messageBar().pushMessage("BathyFlowDEM", "Choose output directory or to load temporary layer.", level=Qgis.Warning)


                else: # if there is a dir path, output path was defined earlier
                    print("Box to laod layer not checked, dir path selected.")
                    """ new_layer = processing.run("native:centroids", {'INPUT':boundary_layer,
                                                                    'ALL_PARTS':False,
                                                                    'OUTPUT': output_path}) """
                    self.iface.messageBar().pushMessage("BathyFlowDEM", "Finished. New layer saved at " + output_path, level=Qgis.Success)
      
            


