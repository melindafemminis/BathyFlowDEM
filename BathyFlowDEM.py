# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BathyFlowDEM
                                 A QGIS plugin
 Interpolation plugin for bathymetric data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-12-28
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Melinda Femminis
        email                : Contact
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from doctest import OutputChecker
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

import math

from qgis.core import Qgis, QgsProject, QgsVectorDataProvider, QgsField, QgsFeatureRequest, QgsRasterLayer, QgsAggregateCalculator
from qgis.utils import iface
from qgis.core.additions.edit import edit
from qgis.gui import QgsMessageBar
import processing

from osgeo import gdal, osr
from osgeo.gdalconst import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .BathyFlowDEM_dialog import BathyFlowDEMDialog

import os.path
from qgis.core import QgsMapLayerProxyModel, QgsFieldProxyModel






class BathyFlowDEM:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):

        # Save reference to the QGIS interface
        self.iface = iface                                                                                                                          
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'BathyFlowDEM_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&BathyFlowDEM')

        # Create instance of dialog class
        self.dlg = BathyFlowDEMDialog()

        


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('BathyFlowDEM', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action
    






    ########################################################################
    ## To install and uninstall plugin
    ########################################################################
    
    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI.
        Called only once on install (or on reload if dev)
        """

        icon_path = ':/plugins/BathyFlowDEM/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Create DEM'),
            callback=self.run,
            parent=self.iface.mainWindow())
        
        self.dlg.boxRMSEresults.hide()

        # Connect dialog signals and slots for user interaction with GUI
        self.dlg.cbInputPointLayer.layerChanged.connect(self.oncbInputPointLayerWidget_layerChanged)
        self.dlg.cbTempLayer.stateChanged.connect(self.oncbTempLayer_stateChanged)
        self.dlg.buttonOK.clicked.connect(self.onStart)
        self.dlg.buttonCancel.clicked.connect(self.onCancel)

        # Populate attribute field 
        self.oncbInputPointLayerWidget_layerChanged()

        # Create message bar for user communication // ui must be in vertical layout
        self.plugin_message_bar = QgsMessageBar()
        self.dlg.verticalLayout.insertWidget(0, self.plugin_message_bar)


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI when uninstalling plugin"""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&BathyFlowDEM'),
                action)
            self.iface.removeToolBarIcon(action)








    ########################################################################
    ## Tests and checks
    ########################################################################

    def allFieldsHaveLayer(self):

        points = self.dlg.cbInputPointLayer.currentLayer()
        centerline = self.dlg.cbInputVectorCenterline.currentLayer()
        polygon = self.dlg.cbInputROI.currentLayer()

        if points == None or centerline == None or polygon == None:
           return False
        else: 
            return True


    def outputPathExists(self):

        path = self.dlg.saveDirWidget.filePath() 

        if not path: 
            return False
        else:
            return True









    ########################################################################
    ## Methods linkes to Qt Widgets
    ########################################################################
    
    def clearMessageBar(self):
        self.plugin_message_bar.clearWidgets()


    def onStart(self):
        """
        Called when the OK button is clicked. 
        Tests validity of the data and run the main function run()
        """

        self.dlg.boxRMSEresults.hide()

        # Checks validity of user's inputs
        if self.allFieldsHaveLayer() == False:
           self.plugin_message_bar.pushMessage("Warning", "All input fields must have a layer selected.", level=Qgis.Warning)
        elif self.dlg.cbTempLayer.isChecked() == False and self.outputPathExists() == False:
            self.plugin_message_bar.pushMessage("Warning", "Set output path or check 'Save to  temporary layer'.", level=Qgis.Warning)
        else: 
            self.run()


    def onCancel(self):
        """
        Called when the Cancel button is clicked.
        Closes the plugin window.
        """
        self.clearMessageBar()
        self.dlg.close()


    def oncbInputPointLayerWidget_layerChanged(self):
        """Slot method called when the seleted layer in cbInputPointLayer is changed"""

        current_point_layer = self.dlg.cbInputPointLayer.currentLayer()
        self.dlg.cbAttField.setLayer(current_point_layer)
        self.dlg.cbAttField.setFilters(QgsFieldProxyModel.Numeric)


    def oncbTempLayer_stateChanged(self):
        """
        Slot method called when cbTempLayer checkbox's state changes. (click)
        """

        cbTempLayer = self.dlg.cbTempLayer

        if cbTempLayer.isChecked() == True: 
            self.dlg.saveDirWidget.setEnabled(False)
            self.dlg.cbOpenOutputFile.setEnabled(False)
        else: 
            self.dlg.saveDirWidget.setEnabled(True)
            self.dlg.cbOpenOutputFile.setEnabled(True)
            







    ########################################################################
    ## Methods to get S, N and flow direction 
    ########################################################################
    
    def get_s_and_flow_direction(self, point_layer, centerline):
        """
        Calculates for each point the distance along a line , the side of the line it's on and segment direction.

        Args:
            centerline_layer (QgsVectorLayer): Input layer with a single line of flow direction
            survey_points_layer (QgsVectorLayer): Input layer with points

        Returns:
            dictionnary: Key is point ID with side, distance along line and flowdir values.
        """


        # Initialize a dictionary to store the values
        results_dir = {}

        line_feature = next(centerline.getFeatures())
        line_geom = line_feature.geometry()

        # Iterate over each feature in the point layer
        for point_feature in point_layer.getFeatures():
            point_geom = point_feature.geometry()
            minDist, closest_pt, afterVertex, leftOf = line_geom.closestSegmentWithContext(point_geom.asPoint())

            # To know on which side of the center line the point lies
            side = leftOf

            # To know the distance along the center line for each point
            distance_along_line = line_geom.lineLocatePoint(point_geom)

            # To know flow direction, get vertex before and after point
            before_vertex_index = afterVertex - 1

            start_point = line_geom.vertexAt(before_vertex_index)
            end_point = line_geom.vertexAt(afterVertex)

            # Calculate flow direction as an angle
            if start_point and end_point:

                dx = end_point.x() - start_point.x()
                dy = end_point.y() - start_point.y()
                # Calculates the angle in radians of the segment relative to the horizontal axis, 
                # taking into account the correct quadrant.
                angle_rad = math.atan2(dy, dx)
                angle_deg = math.degrees(angle_rad)
            else:
                angle_deg = None
        
            results_dir[point_feature.id()] = {'side': side, 
                                                'distance_along_line': distance_along_line,
                                                'flowdir': angle_deg}

        return results_dir


    def shortest_dist(self, point_layer, centerline):


        short_dist_params = {'SOURCE': point_layer,
                            'DESTINATION': centerline,
                            'METHOD': 0,
                            'NEIGHBORS': 1,
                            'END_OFFSET': 0,
                            'OUTPUT': 'TEMPORARY_OUTPUT'}

        result_layer = processing.run("native:shortestline", short_dist_params)['OUTPUT']

        return result_layer







    ########################################################################
    ## Functions to create and process new layers
    ########################################################################

    def create_sample_points(self, survey_points_layer, pixel_size, ROI):
        ''' 
        Creates new raster layer and sample 1 point per pixel

        Args: 
            survey_points_layer (QgsVectorLayer): containing original survey points. used to retrieve CRS
            ROI (QgsVectorLayer): Region Of Interest, boundary layer used to retrieve extent
            pixel_size (Int): user defined pixel size

        Returns:
            QgsRasterLayer with the new raster
            QgsVectorLayer with the sampled points
        '''

        # Create raster layer
        create_raster_params = {'EXTENT': ROI.extent(),
                                'TARGET_CRS': survey_points_layer.crs(),
                                'PIXEL_SIZE': pixel_size,
                                'OUTPUT_TYPE': 5,
                                'OUTPUT': 'TEMPORARY_OUTPUT'}
        
        created_raster = processing.run("native:createconstantrasterlayer", create_raster_params)
        new_raster = QgsRasterLayer(created_raster['OUTPUT'], 'Grid_empty')


        # Sample one point per pixel
        pixelpoint_params = {'INPUT_RASTER': new_raster,
                             'RASTER_BAND': 1,
                             'FIELD_NAME': 'VALUE',
                             'OUTPUT': 'TEMPORARY_OUTPUT'}
        
        sampled_points = processing.run("native:pixelstopoints", pixelpoint_params)['OUTPUT']

        return new_raster, sampled_points


    def layer_to_raster_and_nodata(self, raster, nodata):
        """
        Converts the output of a raster algorithm and adds nodata value to its band 1

        Args:
            raster (QgsRasterLayer)
            nodata (int/float): to add to the nodata values

        Returns:
            raster (QgsRasterLayer); named Interpolated raster with nodata set
        """

        final_raster = QgsRasterLayer(raster, 'Interpolated raster')
        provider = final_raster.dataProvider()
        provider.setNoDataValue(1, nodata)
        final_raster.triggerRepaint()
        
        return final_raster







    ########################################################################
    ## Interpolation with anisotropy
    ########################################################################
        
    def eidw(self, target_s, target_n, value_field, point_layer, anisotropy_ratio, max_distance):
        """
        Perform IDW interpolation using anisotropy along the already aligned S and N coordinates.

        Args:
            point_layer (QgsVectorLayer): Input layer with point features containing S, N, and Z.
            value_field (str): Name of the field with values to interpolate.
            target_s (float): Target point's S coordinate.
            target_n (float): Target point's N coordinate.
            anisotropy_ratio (float): Factor by which distances across the flow (N direction) are scaled.

        Returns:
            float: Interpolated value at the target location or 0 if no data
        """
        sum_weighted_values = 0
        sum_weights = 0
        distances = []
        
        for feature in point_layer.getFeatures():
            s = feature['S']
            n = feature['N']
            value = feature[value_field]
            
            # Calculate distances in the S and N directions
            ds = s - target_s

            # Same to n but take into account negative numbers
            if target_n and n >= 0:
                dn1 = abs(target_n - n)
            elif target_n and n < 0: 
                dn1 = abs(target_n - n)
            else: 
                dn1 = abs(target_n) + abs(n)
            dn = dn1 * anisotropy_ratio

            # Calculate the anisotropic distance by modifying it on the N axis
            distance = (ds**2 + dn**2) ** 0.5

            if distance <= max_distance:
                distances.append((distance, value))
            
            if distance < 0.0001:  # If point is right on it/super close
                return value
                        
        if not distances:
            return 0
        else:
            for distance, value, in distances:
                weight = 1 / distance
                sum_weights += weight
                sum_weighted_values += weight * value
            
            return sum_weighted_values / sum_weights
              





    
    ########################################################################
    ## Model validation  
    ########################################################################


    def rmse(self, actual_values, predicted_values):
        
        differences = [pred - act for pred, act in zip(predicted_values, actual_values)]

        squared_differences = [diff ** 2 for diff in differences]

        mean_squared_difference = sum(squared_differences) / len(squared_differences)
        print(f'Mean squared difference: {mean_squared_difference}')
        rmse = math.sqrt(mean_squared_difference)
        
        return rmse

















    def run(self):
        """Main method"""


        ########################################################################
        ## Set the dialog window, restrictions and updates
        ########################################################################

        # Restrict the type of layer that can be selected in the combo boxes
        self.dlg.cbInputROI.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dlg.cbInputPointLayer.setFilters(QgsMapLayerProxyModel.PointLayer)
        self.dlg.cbInputVectorCenterline.setFilters(QgsMapLayerProxyModel.LineLayer)

        # Show the dialog
        self.dlg.show()

        # Run the dialog event loop
        result = self.dlg.exec_()

        # Populate attribute field with selected point layer - and update if changed
        self.oncbInputPointLayerWidget_layerChanged()

        # Enables/disablesQgsFileWidget
        self.oncbTempLayer_stateChanged()


        if result:


            ########################################################################
            ## Get selected user's values INPUTS and OUTPUT choice/destination
            ########################################################################

            # Get user input layers an
            point_layer = self.dlg.cbInputPointLayer.currentLayer()
            centerline_layer = self.dlg.cbInputVectorCenterline.currentLayer()
            boundary_layer = self.dlg.cbInputROI.currentLayer()

            # Get name of field to interpolate
            field_to_interpolate = str(self.dlg.cbAttField.currentText())

            # Other parameters
            cell_size = self.dlg.sbCellSize.value()
            anisotropy_value = self.dlg.sbAnisotropyValue.value()
            max_distance = self.dlg.sbMaxDist.value()

            # Get user choice for saving final layer
            if self.dlg.cbTempLayer.isChecked():      
                saving_option = 'Save to temporary layer'
            else:
                if self.dlg.cbOpenOutputFile.isChecked():
                    saving_option = 'Save to folder and load'
                else: 
                    saving_option = 'Save to folder only'


        


            
            ########################################################################
            ## Create new points layer with X, Y, S and N coordinates and flow direction
            ########################################################################       

            # Clone input shp point layer: comes with all attributes: id, X and Y
            point_layer.selectAll()
            point_layer_SN = processing.run("native:saveselectedfeatures", {'INPUT': point_layer,
                                                                               'OUTPUT': 'TEMPORARY_OUTPUT'})['OUTPUT']
            point_layer.removeSelection()
            point_layer_SN.setName('points_xy_and_sn')
            
            # To enable check of a particular capability 
            pl_caps = point_layer_SN.dataProvider().capabilities()

            # Create list of new fields
            pl_new_fields = [
                QgsField("S", QVariant.Double),
                QgsField("N", QVariant.Double),
                QgsField("FlowDir", QVariant.Double),
            ]

            # Add fields to layer and update layer
            if pl_caps & QgsVectorDataProvider.AddAttributes:
                 point_layer_SN.dataProvider().addAttributes(pl_new_fields)
            point_layer_SN.updateFields()


            # Calculate S, N and flow direction
            shortest_dist_point_centerline_layer = self.shortest_dist(point_layer_SN, centerline_layer)
            infos_dict = self.get_s_and_flow_direction(point_layer_SN, centerline_layer)


            # Populate the new layer with S, N and FlowDir values
            with edit(point_layer_SN):


                for f in point_layer_SN.getFeatures():

                    # Retrieve n, calculated by the shortest_distance algorithm
                    iterator = shortest_dist_point_centerline_layer.getFeatures(QgsFeatureRequest().setFilterFid(f.id()))
                    feature = next(iterator)
                    n_coordinate = feature['distance']
                    
                    # Change the sign to negative according to which side of the centerline the point it located
                    if infos_dict[f.id()]['side'] == -1:
                        n_coordinate *= -1

                    flow_direction =  infos_dict[f.id()]['flowdir']

                    s_coordinate = infos_dict[f.id()]['distance_along_line']

                    # Add values to the layer
                    point_layer_SN.changeAttributeValue(f.id(), 1, s_coordinate)
                    point_layer_SN.changeAttributeValue(f.id(), 2, n_coordinate)   
                    point_layer_SN.changeAttributeValue(f.id(), 3, flow_direction)      

            # Add new layer to project
            QgsProject.instance().addMapLayer(point_layer_SN)




            ########################################################################
            ## Prepare new layers for interpolation
            ########################################################################   

            raster_ROI_extent, sampled_points = self.create_sample_points(point_layer, cell_size, boundary_layer)

            # Prepare fields for the sampled_points layer
            sp_caps = sampled_points.dataProvider().capabilities()

            # Delete VALUE field created by pixel to layer native algorithm
            if sp_caps & QgsVectorDataProvider.DeleteAttributes:
                sampled_points.dataProvider().deleteAttributes([0])

            # Create list of new fields
            sp_new_fields = [
                QgsField("S", QVariant.Double),
                QgsField("N", QVariant.Double),
                QgsField("Interpolated", QVariant.Double)
            ]

            # Add fields to layer and update layer
            if sp_caps & QgsVectorDataProvider.AddAttributes:
                 sampled_points.dataProvider().addAttributes(sp_new_fields)
            sampled_points.updateFields()


            # Get S and S for each points
            shortest_dist_point_centerline_layer_sampled = self.shortest_dist(sampled_points, centerline_layer)
            infos_dict_sampled = self.get_s_and_flow_direction(sampled_points, centerline_layer)

            # Populate the new layer with S, N and FlowDir values
            with edit(sampled_points):

                for f in sampled_points.getFeatures():

                    # Retrieve n, calculated by the shortest_distance algorithm
                    iterator = shortest_dist_point_centerline_layer_sampled.getFeatures(QgsFeatureRequest().setFilterFid(f.id()))
                    feature = next(iterator)
                    n_coordinate = feature['distance']
                    
                    # Change the sign to negative according to which side of the centerline the point it located
                    if infos_dict_sampled[f.id()]['side'] == -1:
                        n_coordinate *= -1

                    s_coordinate = infos_dict_sampled[f.id()]['distance_along_line']

                    # Add values to the layer
                    sampled_points.changeAttributeValue(f.id(), 0, s_coordinate) 
                    sampled_points.changeAttributeValue(f.id(), 1, n_coordinate)




            
            ########################################################################
            ## interpolate value for each point
            ########################################################################  
                    
            with edit(sampled_points):
                for f in sampled_points.getFeatures():

                    # Get interpolated value for the point
                    interpolated_value = self.eidw(target_s=f['S'], 
                                                    target_n=f['N'], 
                                                    value_field=field_to_interpolate, 
                                                    point_layer=point_layer_SN, 
                                                    anisotropy_ratio=anisotropy_value, 
                                                    max_distance=max_distance)

                    sampled_points.changeAttributeValue(f.id(), 2, interpolated_value)
            
            QgsProject.instance().addMapLayer(sampled_points)


            
         




            ########################################################################
            ## Add interpolated values to raster cells 
            ########################################################################   

            # Create full path to save final raster
            folder_path = self.dlg.saveDirWidget.filePath()
            dataname = 'Interpolated raster'
            full_path = os.path.join(folder_path, dataname + '.tif' )
            
            # Parameters is temporary layer 
            params = {
                'INPUT': sampled_points,
                'FIELD': 'Interpolated',
                'DATA_TYPE': 5,
                'BURN': 0,
                'USE_Z':False,
                'UNITS':1,
                'WIDTH': cell_size,
                'HEIGHT': cell_size,
                'EXTENT': raster_ROI_extent.extent(),
                'OUTPUT': 'TEMPORARY_OUTPUT'
            }

            # Parameters of save to folder
            params_save = {
                'INPUT': sampled_points,
                'FIELD': 'Interpolated',
                'DATA_TYPE': 5,
                'BURN': 0,
                'USE_Z':False,
                'UNITS':1,
                'WIDTH': cell_size,
                'HEIGHT': cell_size,
                'EXTENT': raster_ROI_extent.extent(),
                'OUTPUT': full_path
            }

            if saving_option == 'Save to temporary layer':    

                rasterize_raster = processing.run("gdal:rasterize", params)['OUTPUT']
                final_raster = self.layer_to_raster_and_nodata(rasterize_raster, 0) # QgsRasterLayer to output + nodata
                QgsProject.instance().addMapLayer(final_raster)

                self.plugin_message_bar.pushMessage("Success", "File loaded to project.", level=Qgis.Success)

            else:
                if saving_option == 'Save to folder and load':
                    rasterize_raster = processing.run("gdal:rasterize", params_save)['OUTPUT']
                    final_raster = self.layer_to_raster_and_nodata(rasterize_raster, 0) # QgsRasterLayer to output + nodata
                    QgsProject.instance().addMapLayer(final_raster)

                    self.plugin_message_bar.pushMessage("Success", f"File loaded and saved to {full_path}.", level=Qgis.Success)

                elif saving_option == 'Save to folder only':
                    rasterize_raster = processing.run("gdal:rasterize", params_save)['OUTPUT']
                    final_raster = self.layer_to_raster_and_nodata(rasterize_raster, 0) # QgsRasterLayer to output + nodata

                    self.plugin_message_bar.pushMessage("Success", f"File loaded and saved to {full_path}.", level=Qgis.Success)
                    






            ########################################################################
            ## For each input point in the ROI, calculate the difference between actual point and raster cell
            ########################################################################   

            if self.dlg.cbModelEvaluation.isChecked():

                # Select only points used for interpolation
                clip_params = {
                    'INPUT': point_layer, 
                    'OVERLAY': boundary_layer,
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                }
                used_points = processing.run("native:clip", clip_params)['OUTPUT']

                sample_params = {
                    'INPUT': used_points,
                    'RASTERCOPY': final_raster,
                    'COLUMN_PREFIX': 'SAMPLE_',
                    'OUTPUT': 'TEMPORARY_OUTPUT'
                }

                used_points_with_sampled_raster = processing.run("native:rastersampling", sample_params)['OUTPUT']
                used_points_with_sampled_raster.setName('Data validation - differences')

                QgsProject.instance().addMapLayer(used_points_with_sampled_raster)

                actual_values = used_points_with_sampled_raster.aggregate(QgsAggregateCalculator.ArrayAggregate, field_to_interpolate)[0]
                predicted_values = used_points_with_sampled_raster.aggregate(QgsAggregateCalculator.ArrayAggregate, 'SAMPLE_1')[0]

                rmse =self.rmse(actual_values, predicted_values,)
                
                self.dlg.boxRMSEresults.show()
                self.dlg.labelRMSE.setText(f"Final RMSE: {rmse}")
            
